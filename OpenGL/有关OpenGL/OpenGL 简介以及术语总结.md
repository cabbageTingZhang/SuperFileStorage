
##OpenGL简介
* OpenGL （Open Graphics Library）是⼀个跨编程语⾔、跨平台的编程图形程序接⼝，它将计算机的资源抽象称为⼀个个OpenGL的对象，对这些资源的操作抽象为⼀个个的OpenGL指令。
* OpenGL ES （OpenGL for Embedded Systems）是 OpenGL 三维图形 API 的⼦集，针对⼿机、PDA和游戏主机等嵌⼊式设备⽽设计，去除了许多不必要和性能较低的API接⼝。
* DirectX 是由很多API组成的，DirectX并不是⼀个单纯的图形API. 最重要的是DirectX是属于Windows上⼀个多媒体处理API.并不⽀持Windows以外的平台,所以不是跨平台框架. 按照性质分类，可以分为四⼤部分，显示部分、声⾳部分、输⼊部分和⽹络部分。
* Metal : Metal: Apple为游戏开发者推出了新的平台技术 Metal，该技术能够为 3D 图像提⾼ 10 倍的渲染性能.Metal 是Apple为了解决3D渲染⽽推出的框架 。

其次：苹果在2018年宣称弃用OpenGL、OpenGL ES等。其实还是可以用的，学习OpenGL相关的知识对我们iOS开发还是非常有用的。

OpenGL /OpenGL ES/ Metal 在任何项⽬中解决问题的本质就是利⽤GPU芯⽚来⾼效渲染图形图像. 图形API 是iOS开发者唯⼀接近GPU的⽅式. 

##OpenGL专业名词解析

###OpenGL上下文[context]
* 在应⽤程序调⽤任何OpenGL的指令之前，需要安排⾸先创建⼀个OpenGL的上下⽂。这个上下⽂是⼀个⾮常庞⼤的状态机，保存了OpenGL中的各种状态，这也是OpenGL指令执⾏的基础.
* OpenGL的函数不管在哪个语⾔中，都是类似C语⾔⼀样的⾯向过程的函数，本质上都是对OpenGL上下⽂这个庞⼤的状态机中的某个状态或者对象进⾏操作，当然你得⾸先把这个对象设置为当前对象。因此，通过对OpenGL指令的封装，是可以将OpenGL的相关调⽤封装成为⼀个⾯向对象的图形API的.
* 由于OpenGL上下⽂是⼀个巨⼤的状态机，切换上下⽂往往会产⽣较⼤的开销，但是不同的绘制模块，可能需要使⽤完全独⽴的状态管理。因此，可以在应⽤程序中分别创建多个不同的上下⽂，在不同线程中使⽤不同的上下⽂，上下⽂之间共享纹理、缓冲区等资源。这样的⽅案，会⽐反复切换上下⽂，或者⼤量修改渲染状态，更加合理⾼效的. 

###OpenGL状态机
• 状态机是理论上的⼀种机器.这个⾮常难以理解.所以我们把这个状态机这么理解.状态机描述了⼀个对象在其⽣命周期内所经历的各种状态，状态间的转变，发⽣转变的动因，条件及转变中所执⾏的活动。或者说，状态机是⼀种⾏为，说明对象在其⽣命周期中响应事件所经历的状态序列以及对那些状态事件的响应。因此具有以下特点：
1.  有记忆功能，能记住其当前的状态.
2. 可以接收输⼊，根据输⼊的内容和⾃⼰的原先状态，修改⾃⼰当前状态，并且可以有对应输出.
3. 当进⼊特殊状态（停机状态）的时候，变不再接收输⼊，停⽌⼯作；

* 类推到OpenGL中来, 可以这么理解:
1. OpenGL可以记录⾃⼰的状态（如当前所使⽤的颜⾊、是否开启了混合功能等）
2.  OpenGL可以接收输⼊（当调⽤OpenGL函数的时候，实际上可以看成OpenGL在接收我们的输⼊），如我们调⽤glColor3f，则OpenGL接收到这个输⼊后会修改⾃⼰的“当前颜⾊”这个状态；
3. OpenGL可以进⼊停⽌状态，不再接收输⼊。在程序退出前，OpenGL总会先停⽌⼯作的；

###渲染
将图形/图像数据转换成3D空间图像操作叫做渲染(Rendering).

###顶点数组(VertexArray)和顶点缓冲区（VertexBuffer) 
* 画图⼀般是先画好图像的⻣架，然后再往⻣架⾥⾯填充颜⾊，这对于OpenGL也是⼀样的。顶点数据就是要画的图像的⻣架，和现实中不同的是，OpenGL中的图像都是由图元组成。在OpenGLES中，有3种类型的图元：点、线、三⻆形。那这些顶点数据最终是存储在哪⾥的呢？开发者可以选择设定函数指针，在调⽤绘制⽅法的时候，直接由内存传⼊顶点数据，也就是说这部分数据之前是存储在内存当中的，被称为顶点数组。⽽性能更⾼的做法是，提前分配⼀块显存，将顶点数据预先传⼊到显存当中。这部分的显存，就被称为顶点缓冲区.
* 顶点指的是我们在绘制⼀个图形时,它的顶点位置数据.⽽这个数据可以直接 逻辑教育存储在数组中或者将其缓存到GPU内存中.

###管线
在OpenGL 下渲染图形,就会有经历⼀个⼀个节点.⽽这样的操作可以理解管线.⼤家可以想象成流⽔线.每个任务类似流⽔线般执⾏.任务之间有先后顺序. 管线是⼀个抽象的概念，之所以称之为管线是因为显卡在处理数据的时候是按照⼀个固定的顺序来的，⽽且严格按照这个顺序。就像⽔从⼀根管⼦的⼀端流到另⼀端，这个顺序是不能打破的.

###固定管线/存储着⾊器
* 在早期的OpenGL 版本,它封装了很多种着⾊器程序块内置的⼀段包含了光照、坐标变换、裁剪等等诸多功能的固定shader程序来完成,来帮助开发者来完成图形的渲染. ⽽开发者只需要传⼊相应的参数,就能快速完成图形的渲染. 类似于iOS开发会封装很多API,⽽我们只需要调⽤,就可以实现功能.不需要关注底层实现原理.
* 但是由于OpenGL 的使⽤场景⾮常丰富,固定管线或存储着⾊器⽆法完成每⼀ 逻辑教育
个业务.这时将相关部分开放成可编程.

###着色器程序Shader
* 就全⾯的将固定渲染管线架构变为了可编程渲染管线。因此，OpenGL在实际调⽤绘制函数之前，还需要指定⼀个由shader编译成的着⾊器程序。常⻅的着⾊器主要有顶点着⾊器（VertexShader），⽚段着⾊器（FragmentShader）/像素着⾊器（PixelShader），⼏何着⾊器（GeometryShader），曲⾯细分着⾊器（TessellationShader）。⽚段着⾊器和像素着⾊器只是在OpenGL和DX中的不同叫法⽽已。可惜的是，直到OpenGLES 3.0，依然只⽀持了顶点着⾊器和⽚段着⾊器这两个最基础的着⾊器。
* OpenGL在处理shader时，和其他编译器⼀样。通过编译、链接等步骤，⽣成了着⾊器程序（glProgram），着⾊器程序同时包含了顶点着⾊器和⽚段着⾊器的运算逻辑。在OpenGL进⾏绘制的时候，⾸先由顶点着⾊器对传⼊的顶点数据进⾏运算。再通过图元装配，将顶点转换为图元。然后进⾏光栅化，将图元这种⽮量图形，转换为栅格化数据。最后，将栅格化数据传⼊⽚段着⾊器中进⾏运算。⽚段着⾊器会对栅格化数据中的每⼀个像素进⾏运算，并决定像素的颜⾊.

###顶点着⾊器VertexShader 
* ⼀般⽤来处理图形每个顶点变换(旋转/平移/投影等) .
* 顶点着⾊器是OpenGL中⽤于计算顶点属性的程序。顶点着⾊器是逐顶点运算的程序，也就是说每个顶点数据都会执⾏⼀次顶点着⾊器，当然这是并⾏的，并且顶点着⾊器运算过程中⽆法访问其他顶点的数据.
* ⼀般来说典型的需要计算的顶点属性主要包括顶点坐标变换、逐顶点光照运算等等。顶点坐标由⾃身坐标系转换到归⼀化坐标系的运算，就是在这⾥发⽣的。

###⽚元着⾊器程序FragmentShader 
* ⼀般⽤来处理图形中每个像素点颜⾊计算和填充.
* ⽚段着⾊器是OpenGL中⽤于计算⽚段（像素）颜⾊的程序。⽚段着⾊器是逐像素运算的程序，也就是说每个像素都会执⾏⼀次⽚段着⾊器，当然也是并⾏的.

###GLSL(OpenGL Shading Language) 
* OpenGL着⾊语⾔（OpenGL Shading Language）是⽤来在OpenGL中着⾊编程的语⾔，也即开发⼈员写的短⼩的⾃定义程序，他们是在图形卡的GPU （Graphic Processor Unit图形处理单元）上执⾏的，代替了固定的渲染管线的⼀部分，使渲染管线中不同层次具有可编程性。⽐如：视图转换、投影转换等。GLSL（GL Shading Language）的着⾊器代码分成2个部分：Vertex Shader（顶点着⾊器）和Fragment（⽚断着⾊器）.

###光栅化Rasterization 
* 是把顶点数据转换为⽚元的过程，具有将图转化为⼀个个栅格组成的图象的作⽤，特点是每个元素对应帧缓冲区中的⼀像素。
* 光栅化就是把顶点数据转换为⽚元的过程。⽚元中的每⼀个元素对应于帧缓冲区中的⼀个像素。
* 光栅化其实是⼀种将⼏何图元变为⼆维图像的过程。该过程包含了两部分的⼯作。第⼀部分⼯作：决定窗⼝坐标中的哪些整型栅格区域被基本图元占⽤；第⼆部分⼯作：分配⼀个颜⾊值和⼀个深度值到各个区域。光栅化过程产⽣的是⽚元.
*  把物体的数学描述以及与物体相关的颜⾊信息转换为屏幕上⽤于对应位置的像素及⽤于填充像素的颜⾊，这个过程称为光栅化，这是⼀个将模拟信号转化为离散信号的过程.

###纹理
* 纹理可以理解为图⽚. ⼤家在渲染图形时需要在其编码填充图⽚,为了使得场景更加逼真.⽽这⾥使⽤的图⽚,就是常说的纹理.但是在OpenGL,我们更加习惯叫纹理,⽽不是图⽚.

###混合（Blending) 
* 在测试阶段之后，如果像素依然没有被剔除，那么像素的颜⾊将会和帧缓冲区中颜⾊附着上的颜⾊进⾏混合，混合的算法可以通过OpenGL的函数进⾏指定。但是OpenGL提供的混合算法是有限的，如果需要更加复杂的混合算法，⼀般可以通过像素着⾊器进⾏实现，当然性能会⽐原⽣的混合算法差⼀些.

###变换矩阵(Transformation) 
* 例如图形想发⽣平移,缩放,旋转变换.就需要使⽤变换矩阵.

###投影矩阵Projection 
* ⽤于将3D坐标转换为⼆维屏幕坐标,实际线条也将在⼆维坐标下进⾏绘制.

###渲染上屏/交换缓冲区(SwapBuffer) 
* 渲染缓冲区⼀般映射的是系统的资源⽐如窗⼝。如果将图像直接渲染到窗⼝对应的渲染缓冲区，则可以将图像显示到屏幕上。
* 但是，值得注意的是，如果每个窗⼝只有⼀个缓冲区，那么在绘制过程中屏幕进⾏了刷新，窗⼝可能显示出不完整的图像.
* 为了解决这个问题，常规的OpenGL程序⾄少都会有两个缓冲区。显示在屏幕上的称为屏幕缓冲区，没有显示的称为离屏缓冲区。在⼀个缓冲区渲染完成之后，通过将屏幕缓冲区和离屏缓冲区交换，实现图像在屏幕上的显示。
* 由于显示器的刷新⼀般是逐⾏进⾏的，因此为了防⽌交换缓冲区的时候屏幕上下区域的图像分属于两个不同的帧，因此交换⼀般会等待显示器刷新完成的信号，在显示器两次刷新的间隔中进⾏交换，这个信号就被称为垂直同步信号，这个技术被称为垂直同步.
* 使⽤了双缓冲区和垂直同步技术之后，由于总是要等待缓冲区交换之后再进⾏下⼀帧的渲染，使得帧率⽆法完全达到硬件允许的最⾼⽔平。为了解决这个问题，引⼊了三缓冲区技术，在等待垂直同步时，来回交替渲染两个离屏的缓冲区，⽽垂直同步发⽣时，屏幕缓冲区和最近渲染完成的离屏缓冲区交换，实现充分利⽤硬件性能的⽬的.
